import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as s,c,a as e,b as t,d as r,f as a}from"./app-3f278ba4.js";const i={},h=e("h1",{id:"requests-请求",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#requests-请求","aria-hidden":"true"},"#"),t(" Requests（请求）")],-1),u=e("blockquote",null,[e("p",null,"如果你正在做基于REST的Web服务...你最好忽略request.POST。")],-1),l={href:"https://groups.google.com/d/topic/django-developers/dxI4qVzrBY4/discussion",target:"_blank",rel:"noopener noreferrer"},_=a('<p>REST framework的<code>Request</code>类扩展了标准的<code>HttpRequest</code>，添加对REST framework的灵活请求解析和请求身份验证的支持。</p><hr><h2 id="request-parsing-请求解析" tabindex="-1"><a class="header-anchor" href="#request-parsing-请求解析" aria-hidden="true">#</a> Request parsing（请求解析）</h2><p>REST framework的请求对象提供灵活的请求解析，允许你以与通常处理表单数据相同的方式使用JSON数据或其他媒体类型处理请求。</p><h3 id="data" tabindex="-1"><a class="header-anchor" href="#data" aria-hidden="true">#</a> .data</h3><p><code>request.data</code> 返回请求正文的解析内容。这与标准的 <code>request.POST</code> 和 <code>request.FILES</code> 属性类似，除了下面的：</p><ul><li>它包括所有解析的内容, 包括 <em>文件或非文件</em> 输入。</li><li>它支持解析除<code>POST</code>之外的HTTP方法的内容，这意味着你可以访问<code>PUT</code>和<code>PATCH</code>请求的内容。</li><li>它支持REST framework灵活的请求解析，而不仅仅支持表单数据。 例如，你可以以与处理传入表单数据相同的方式处理传入的JSON数据。</li></ul>',7),p={href:"https://q1mi.github.io/Django-REST-framework-documentation/api-guide/parsers_zh/",target:"_blank",rel:"noopener noreferrer"},m=a('<h3 id="query-params" tabindex="-1"><a class="header-anchor" href="#query-params" aria-hidden="true">#</a> .query_params</h3><p><code>request.query_params</code>是<code>request.GET</code>的一个更准确的同义词。<br> 为了让你的代码清晰明了, 我们建议使用 <code>request.query_params</code> 而不是Django标准的<code>request.GET</code>。这样做有助于保持代码库更加正确和明了——任何HTTP方法类型可能包括查询参数，而不仅仅是<code>GET</code>请求。</p><h3 id="parsers" tabindex="-1"><a class="header-anchor" href="#parsers" aria-hidden="true">#</a> .parsers</h3><p><code>APIView</code>类或<code>@api_view</code>装饰器将根据view中设置的<code>parser_classes</code>集合或基于<code>DEFAULT_PARSER_CLASSES</code>设置，确保此属性自动设置为<code>Parser</code>实例列表。<br> 你通常并不需要访问这个属性。</p><hr><p><strong>Note:</strong> 如果客户端发送格式错误的内容，则访问<code>request.data</code>可能会引发<code>ParseError</code>。默认情况下REST framework的 <code>APIView</code>类或<code>@api_view</code>装饰器将捕获错误并返回<code>400 Bad Request</code>响应。<br> 如果客户端发送具有无法解析的呃逆荣类型的请求，则会引发 <code>UnsupportedMediaType</code> 异常, 默认情况下会捕获该异常并返回 <code>415 Unsupported Media Type</code> 响应。</p><hr><h2 id="content-negotiation-内容协商" tabindex="-1"><a class="header-anchor" href="#content-negotiation-内容协商" aria-hidden="true">#</a> Content negotiation（内容协商）</h2><p>请求提供了一些属性允许你确定内容协商阶段的结果。这允许你实现具体的行为，例如为不同的媒体类型选择不用的序列化方案。</p><h3 id="accepted-renderer" tabindex="-1"><a class="header-anchor" href="#accepted-renderer" aria-hidden="true">#</a> .accepted_renderer</h3><p>由内容协商阶段选择的render实例。</p><h3 id="accepted-media-type" tabindex="-1"><a class="header-anchor" href="#accepted-media-type" aria-hidden="true">#</a> .accepted_media_type</h3><p>由内容协商阶段接受的媒体类型的字符串。</p><hr><h2 id="authentication-认证" tabindex="-1"><a class="header-anchor" href="#authentication-认证" aria-hidden="true">#</a> Authentication（认证）</h2><p>REST framework 提供了灵活的，每次请求的验证，让你能够：</p><ul><li>对API的不同部分使用不同的身份验证策略。</li><li>支持使用多个身份验证策略。</li><li>提供与传入请求相关联的用户和令牌信息。</li></ul><h3 id="user" tabindex="-1"><a class="header-anchor" href="#user" aria-hidden="true">#</a> .user</h3>',18),b=e("code",null,"request.user",-1),q=e("code",null,"django.contrib.auth.models.User",-1),T=e("br",null,null,-1),f=e("code",null,"request.user",-1),g=e("code",null,"django.contrib.auth.models.AnonymousUser",-1),E=e("br",null,null,-1),R={href:"https://q1mi.github.io/Django-REST-framework-documentation/api-guide/authentication/",target:"_blank",rel:"noopener noreferrer"},w=e("h3",{id:"auth",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#auth","aria-hidden":"true"},"#"),t(" .auth")],-1),k=e("code",null,"request.auth",-1),S=e("code",null,"request.auth",-1),x=e("br",null,null,-1),P=e("code",null,"request.auth",-1),A=e("code",null,"None",-1),y=e("br",null,null,-1),H={href:"https://q1mi.github.io/Django-REST-framework-documentation/api-guide/authentication/",target:"_blank",rel:"noopener noreferrer"},D=a('<h3 id="authenticators" tabindex="-1"><a class="header-anchor" href="#authenticators" aria-hidden="true">#</a> .authenticators</h3><p><code>APIView</code> 类或 <code>@api_view</code> 装饰器将根据在view中设置的 <code>authentication_classes</code> 或基于<code>DEFAULT_AUTHENTICATORS</code> 设置，确保此属性自动设置为 <code>Authentication</code> 实例的列表。<br> 你通常并不需要访问此属性。</p><hr><h2 id="browser-enhancements-浏览器增强" tabindex="-1"><a class="header-anchor" href="#browser-enhancements-浏览器增强" aria-hidden="true">#</a> Browser enhancements（浏览器增强）</h2><p>REST framework 支持一些浏览器增强功能，例如基于浏览器的 <code>PUT</code>, <code>PATCH</code> 和 <code>DELETE</code> 表单。</p><h3 id="method" tabindex="-1"><a class="header-anchor" href="#method" aria-hidden="true">#</a> .method</h3>',6),j=e("code",null,"request.method",-1),N=e("strong",null,"大写",-1),v=e("br",null,null,-1),U=e("code",null,"PUT",-1),I=e("code",null,"PATCH",-1),C=e("code",null,"DELETE",-1),L=e("br",null,null,-1),V={href:"https://q1mi.github.io/Django-REST-framework-documentation/topics/browser-enhancements/",target:"_blank",rel:"noopener noreferrer"},O=e("h3",{id:"content-type",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#content-type","aria-hidden":"true"},"#"),t(" .content_type")],-1),B=e("code",null,"request.content_type",-1),M=e("br",null,null,-1),F=e("br",null,null,-1),G=e("code",null,".content_type",-1),z=e("code",null,"request.META.get('HTTP_CONTENT_TYPE')",-1),J=e("br",null,null,-1),Y={href:"https://q1mi.github.io/Django-REST-framework-documentation/topics/browser-enhancements/",target:"_blank",rel:"noopener noreferrer"},W=a('<h3 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> .stream</h3><p><code>request.stream</code> 返回一个表示请求主体内容的流。<br> 你通常不需要直接访问请求的内容类型，因为你通常将依赖于REST framework的默认请求解析行为。</p><hr><h2 id="standard-httprequest-attributes-标准httprequest属性" tabindex="-1"><a class="header-anchor" href="#standard-httprequest-attributes-标准httprequest属性" aria-hidden="true">#</a> Standard HttpRequest attributes（标准HttpRequest属性）</h2><p>由于 REST framework 的 <code>Request</code> 扩展了 Django的 <code>HttpRequest</code>, 所以所有其他标准属性和方法也是可用的。例如 <code>request.META</code> 和 <code>request.session</code> 字典正常可用。<br> 请注意，由于实现原因， <code>Request</code> 类并不会从 <code>HttpRequest</code> 类继承, 而是使用合成扩展类。</p>',5);function K(Q,X){const o=d("ExternalLinkIcon");return s(),c("div",null,[h,u,e("blockquote",null,[e("p",null,[t("— Malcom Tredinnick, "),e("a",l,[t("Django developers group"),r(o)])])]),_,e("p",null,[t("更多详细信息请参阅"),e("a",p,[t("parsers documentation"),r(o)]),t(".")]),m,e("p",null,[b,t(" 通常返回一个 "),q,t(" 实例, 尽管该行为取决于所使用的的认证策略。"),T,t(" 如果请求未认证则 "),f,t(" 的默认值为 "),g,t("的一个实例。"),E,t(" 更多详细信息请查阅 "),e("a",R,[t("authentication documentation"),r(o)]),t(".")]),w,e("p",null,[k,t(" 返回任何其他身份验证上下文。 "),S,t(" 的确切行为取决于所使用的的认证策略，但它通常可以是请求被认证的token的实例。"),x,t(" 如果请求未认证或者没有其他上下文，则 "),P,t(" 的默认值为 "),A,t("."),y,t(" 更多详细信息请查阅 "),e("a",H,[t("authentication documentation"),r(o)]),t(".")]),D,e("p",null,[j,t(" 返回请求的HTTP方法的 "),N,t(" 字符串表示形式。"),v,t(" 透明地支持基于浏览器的 "),U,t(", "),I,t(" 和 "),C,t(" 表单。"),L,t(" 更多详细信息请查阅 "),e("a",V,[t("browser enhancements documentation"),r(o)]),t(".")]),O,e("p",null,[B,t(" 返回表示HTTP请求正文的媒体类型的字符串对象，如果未提供媒体类型，则返回空字符串。"),M,t(" 你通常不需要直接访问请求的内容类型，因为你通常将依赖于REST framework的默认请求解析行为。"),F,t(" 如果你确实需要访问请求的内容类型，你应该使用 "),G,t(" 属性，而不是使用 "),z,t(", 因为它为基于浏览器的非表单内容提供了透明的支持。"),J,t(" 更多详细信息请查阅 "),e("a",Y,[t("browser enhancements documentation"),r(o)]),t(".")]),W])}const ee=n(i,[["render",K],["__file","01.Requests（请求）.html.vue"]]);export{ee as default};
