import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as i,c as n,a as e,b as t,d as o,f as l}from"./app-cfbf85c1.js";const h={},p=l('<h2 id="cypress-简介" tabindex="-1"><a class="header-anchor" href="#cypress-简介" aria-hidden="true">#</a> Cypress 简介</h2><ul><li>基于 <strong>JavaScript</strong> 的前端测试工具，可以对浏览器中运行的任何内容进行快速、简单、可靠的测试</li><li>Cypress 是<strong>自集成</strong>的，提供了一套完整的端到端测试，无须借助其他外部工具，安装后即可快速地创建、编写、运行测试用例，<strong>且对每一步操作都支持回看</strong></li><li>不同于其他只能测试 UI 层的前端测试工具，Cypress 允许编写所有类型的测试，覆盖了测试金字塔模型的所有测试类型**【界面测试，集成测试，单元测试】**</li><li>Cypress 底层协议<strong>不采用</strong> WebDriver</li></ul><figure><img src="https://img2020.cnblogs.com/blog/1896874/202005/1896874-20200526133558556-1578884405.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="cypress-原理" tabindex="-1"><a class="header-anchor" href="#cypress-原理" aria-hidden="true">#</a> Cypress 原理</h2><h4 id="webdriver-运行的方式" tabindex="-1"><a class="header-anchor" href="#webdriver-运行的方式" aria-hidden="true">#</a> Webdriver 运行的方式</h4><ul><li>大多数测试工具（如：Selenium/webdriver）通过在<strong>外部浏览器运行</strong>并在网络上执行远程命令来运行</li><li>因为 Webdriver 底层通信协议基于 JSON Wire Protocol，运行需要网络通信</li></ul><p></p><h4 id="cypress-运行的方式" tabindex="-1"><a class="header-anchor" href="#cypress-运行的方式" aria-hidden="true">#</a> Cypress 运行的方式</h4><p>Cypress 和 Webdriver 方式完全相反，它与应用程序在相同的生命周期里执行</p><h4 id="cypress-运行测试的大致流程" tabindex="-1"><a class="header-anchor" href="#cypress-运行测试的大致流程" aria-hidden="true">#</a> Cypress 运行测试的大致流程</h4><ol><li>运行测试后，Cypress 使用 <strong>webpack</strong> 将测试代码中的<strong>所有模块 bundle</strong> 到一个 js 文件中</li><li>然后，运行浏览器，并且将测试代码注入到一个空白页中，然后它将在浏览器中运行测试代码【**可以理解成：**Cypress 将测试代码放到一个 <strong>iframe</strong> 中运行】</li></ol><p></p><h4 id="cypress-运行测试的技术流程" tabindex="-1"><a class="header-anchor" href="#cypress-运行测试的技术流程" aria-hidden="true">#</a> Cypress 运行测试的技术流程</h4><ol><li>每次测试首次加载 Cypress 时，内部 Cypress Web 应用程序先把自己<strong>托管</strong>在本地的一个随机端口上**【如：http://localhost:65874】**</li><li>在识别出测试中发出的第一个  cy.visit()  命令后，Cypress 会更改本地 URL 以匹配你远程应用程序的 Origin**【满足同源策略】<strong>，这使得你的</strong>测试代码和应用程序<strong>可以在</strong>同一个 Run Loop 中运行  **</li></ol><p></p><h4 id="cypress-运行更快的根本原因" tabindex="-1"><a class="header-anchor" href="#cypress-运行更快的根本原因" aria-hidden="true">#</a> Cypress 运行更快的根本原因</h4><ul><li>Cypress 测试代码和应用程序均运行在由 Cypress 全权控制的浏览器中</li><li>且它们运行<strong>在同一个Domain 下的不同 iframe 中</strong>，所以 Cypress 的测试代码可以直接操作 DOM、Window Objects、Local Storages而<strong>无须通过网络访问</strong></li></ul><p></p><h4 id="cypress-稳定性、可靠性更高的原因" tabindex="-1"><a class="header-anchor" href="#cypress-稳定性、可靠性更高的原因" aria-hidden="true">#</a> Cypress 稳定性、可靠性更高的原因</h4><ul><li>Cypress 还可以在网络层进行<strong>即时读取和更改网络流量</strong>的操作</li><li>Cypress 背后是 <strong>Node.js Process 控制的 Proxy 进行转发</strong>，这使得 Cypress 不仅可以修改进出浏览器的所有内容，还可以更改可能影响自动化操作的代码</li><li>Cypress 相对于其他测试工具来说，能从根本上<strong>控制整个自动化测试的流程</strong></li></ul><p></p><h2 id="cypress-架构图" tabindex="-1"><a class="header-anchor" href="#cypress-架构图" aria-hidden="true">#</a> Cypress 架构图</h2><figure><img src="https://img2020.cnblogs.com/blog/1896874/202005/1896874-20200526144722327-571556348.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="cypress-的特性" tabindex="-1"><a class="header-anchor" href="#cypress-的特性" aria-hidden="true">#</a> Cypress 的特性</h2><h3 id="时间穿梭【历史记录】" tabindex="-1"><a class="header-anchor" href="#时间穿梭【历史记录】" aria-hidden="true">#</a> 时间穿梭【历史记录】</h3><ul><li>Cypress 在测试代码<strong>运行时会自动拍照</strong></li><li>等测试运行结束后，用户可在 Cypress 提供的 <strong>Test Runner</strong> 里，通过悬停在命令上的方式查看运行时每一步都发生了什么</li></ul><p></p><h3 id="实时重新加载" tabindex="-1"><a class="header-anchor" href="#实时重新加载" aria-hidden="true">#</a> 实时重新加载</h3><p>当测试代码修改保存后，Cypress 会自动加载改动地方，并重新运行测试</p><h3 id="spies-间谍-、stubs-存根-、clock-时钟" tabindex="-1"><a class="header-anchor" href="#spies-间谍-、stubs-存根-、clock-时钟" aria-hidden="true">#</a> Spies（间谍）、Stubs（存根）、Clock（时钟）</h3><ul><li>Cypress 允许你验证并控制函数行为，Mock 服务器的响应，更改系统时间</li><li>单元测试触手可及！</li></ul><p></p><h3 id="运行结果一致性" tabindex="-1"><a class="header-anchor" href="#运行结果一致性" aria-hidden="true">#</a> 运行结果一致性</h3><p>Cypress 架构不使用 Selenium 或 Webdriver，在运行速度、可靠性测试、测试结果一致性上均有良好保障</p><h3 id="可调试性" tabindex="-1"><a class="header-anchor" href="#可调试性" aria-hidden="true">#</a> 可调试性</h3><p>当测试失败时，可以直接从开发者工具（F12 Chrome DevTools）进行调试，这熟悉吧？？</p><h3 id="自动等待" tabindex="-1"><a class="header-anchor" href="#自动等待" aria-hidden="true">#</a> 自动等待</h3><ul><li>使用Cypress，永远无须在测试中添加 强制等待、隐性等待、显性等待</li><li>Cypress 会自动等待元素至可靠操作状态时才执行命令或断言</li><li>异步操作触手可及！</li></ul><p></p><h3 id="网络流量控制" tabindex="-1"><a class="header-anchor" href="#网络流量控制" aria-hidden="true">#</a> 网络流量控制</h3><p>Cypress 可以 Mock 服务器返回的结果，无须依赖后端服务器，即可实现模拟网络请求</p><h3 id="截图和视频" tabindex="-1"><a class="header-anchor" href="#截图和视频" aria-hidden="true">#</a> 截图和视频</h3><p>Cypress 在测试运行失败时会自动截图，在无头运行时（无GUI界面）会录制整个测试套件的视频</p><h2 id="cypress-优势的总结" tabindex="-1"><a class="header-anchor" href="#cypress-优势的总结" aria-hidden="true">#</a> Cypress 优势的总结</h2><p>像我们在用 Selenium 时，需要集成单元测试框架（unittest、pytest），想要好看的测试报告还得集成（allure），想要 Mock 还得引入对应的 Mock 库<br> 而 Cypress 是开箱即用！啥意思？看下图！<br><img src="https://img2020.cnblogs.com/blog/1896874/202005/1896874-20200526155620721-2112939345.png" alt="" loading="lazy"></p>',45),d={href:"https://www.cnblogs.com/poloyy/p/12966125.html",target:"_blank",rel:"noopener noreferrer"};function c(y,g){const r=a("ExternalLinkIcon");return i(),n("div",null,[p,e("blockquote",null,[e("p",null,[e("a",d,[t("https://www.cnblogs.com/poloyy/p/12966125.html"),o(r)])])])])}const C=s(h,[["render",c],["__file","Cypress系列（002）--Cypress-框架的详细介绍.html.vue"]]);export{C as default};
