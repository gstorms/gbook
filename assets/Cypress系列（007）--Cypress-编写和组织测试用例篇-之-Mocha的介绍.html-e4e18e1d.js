import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r,o,c as l,a as e,b as s,d as t,f as n}from"./app-731a6e06.js";const h={},c=n('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><ul><li>Cypress 底层依赖于很多优秀的开源测试框架，其中就有 <strong>Mocha</strong></li><li>Mocha 是一个适用于 Node.js 和浏览器的测试框架，它使得异步测试变得简单</li></ul><p></p><h3 id="js-语言带来的问题" tabindex="-1"><a class="header-anchor" href="#js-语言带来的问题" aria-hidden="true">#</a> JS 语言带来的问题</h3><p>JS 是单线程异步执行的，这使得测试变得复杂，因为无法像测试同步执行的代码那样，直接判断函数的返回值是否符合预期（因为给函数赋值时函数可能并未执行）</p><h3 id="如何验证异步函数的正确性" tabindex="-1"><a class="header-anchor" href="#如何验证异步函数的正确性" aria-hidden="true">#</a> 如何验证异步函数的正确性</h3><ul><li>需要测试框架<strong>支持回调</strong>，Promise 或者其他方式来验证异步函数的正确性</li><li>Mocha 提供了出色的<strong>异步支持</strong>包括  Promise ，从而使得异步测试变得简单</li></ul><p></p><h2 id="cypress-结合-mocha" tabindex="-1"><a class="header-anchor" href="#cypress-结合-mocha" aria-hidden="true">#</a> Cypress 结合 Mocha</h2><p>Cypress 继承并扩展了 Mocha 对异步的支持</p><h3 id="mocha-提供了什么" tabindex="-1"><a class="header-anchor" href="#mocha-提供了什么" aria-hidden="true">#</a> Mocha 提供了什么</h3><ul><li>多种接口来定义测试套件，Hooks，单个测试（ Individual ）</li><li>BDD（Behavior-Driven Development，<strong>行为驱动开发</strong>）</li><li>TDD（Test-Driven Development，<strong>测试驱动开发</strong>）</li><li>Exports、QUnit、Require</li></ul><p></p><h3 id="cypress-采纳了-mocha-的-bdd-语法" tabindex="-1"><a class="header-anchor" href="#cypress-采纳了-mocha-的-bdd-语法" aria-hidden="true">#</a> Cypress 采纳了 Mocha 的 BDD 语法</h3><ul><li>该语法<strong>非常适合</strong>集成测试和单元测试</li><li>在 Mocha 中，一个** BDD 风格的测试用例**看起来是这样的</li></ul><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603130100118-1611276041.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="常见-mocha-模块" tabindex="-1"><a class="header-anchor" href="#常见-mocha-模块" aria-hidden="true">#</a> 常见 Mocha 模块</h3><p>Cypress 将 Mocha 硬编码在自己的框架中，所以编写测试用例都是基于 Mocha 提供的如下基本功能模块：</p><ul><li>describe()</li><li>context()</li><li>it()</li><li>before()</li><li>beforeEach()</li><li>afterEach()</li><li>after()</li><li>.only()</li><li>.skip()</li></ul><p></p><h3 id="对于一条可执行的测试用例来说-有以下两个必要的组成部分" tabindex="-1"><a class="header-anchor" href="#对于一条可执行的测试用例来说-有以下两个必要的组成部分" aria-hidden="true">#</a> 对于一条可执行的测试用例来说，有以下两个必要的组成部分</h3><h4 id="describe" tabindex="-1"><a class="header-anchor" href="#describe" aria-hidden="true">#</a> describe()</h4><ul><li>代表测试套件，里面可以设定 context() ，也可以包括多个测试用例 it() ，还能嵌套子测试套件</li><li>一个测试套件可以不包括任何钩子函数（Hook），但必须包含至少一条测试用例 it()</li></ul><p></p><h4 id="it" tabindex="-1"><a class="header-anchor" href="#it" aria-hidden="true">#</a> it()</h4><p>代表一条测试用例</p><h4 id="其他模块" tabindex="-1"><a class="header-anchor" href="#其他模块" aria-hidden="true">#</a> 其他模块</h4><ul><li>除上述两个功能模块外，其他功能模块对于一条可执行的测试来说，都是<strong>可选的</strong></li><li>例如  context() 是 describe() 的别名，其<strong>行为方式是一致</strong>的，直接用 context() 代替 describe() 也是可以的哦</li></ul><p><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603132544618-1397739152.png" alt="" loading="lazy"><br>  可以看到，一共有三层的 context() ；<br> 运行成功看看下面的结果<br><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603132654893-1811386580.png" alt="" loading="lazy"></p>',29),d={href:"https://www.cnblogs.com/poloyy/p/13034592.html",target:"_blank",rel:"noopener noreferrer"};function p(g,_){const a=r("ExternalLinkIcon");return o(),l("div",null,[c,e("blockquote",null,[e("p",null,[e("a",d,[s("https://www.cnblogs.com/poloyy/p/13034592.html"),t(a)])])])])}const m=i(h,[["render",p],["__file","Cypress系列（007）--Cypress-编写和组织测试用例篇-之-Mocha的介绍.html.vue"]]);export{m as default};
