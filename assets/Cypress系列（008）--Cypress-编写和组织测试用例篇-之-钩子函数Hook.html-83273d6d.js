import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as r,c as t,a as e,b as n,d as l,f as h}from"./app-3f278ba4.js";const c={},s=h('<h2 id="hook" tabindex="-1"><a class="header-anchor" href="#hook" aria-hidden="true">#</a> Hook</h2><p>就是常说的钩子函数，在 pytest 框架里面也有 hook 这个概念；接下来就让我们来看看 Mocha 提供的 Hook 函数叭！</p><h2 id="mocha-提供的-hook-函数" tabindex="-1"><a class="header-anchor" href="#mocha-提供的-hook-函数" aria-hidden="true">#</a> Mocha 提供的 Hook 函数</h2><ul><li>before()</li><li>beforeEach()</li><li>afterEach()</li><li>after()</li></ul><p></p><h3 id="hook-的作用" tabindex="-1"><a class="header-anchor" href="#hook-的作用" aria-hidden="true">#</a> hook 的作用</h3><p>利用钩子函数可以在所有<strong>测试用例执行前</strong>做一些预置操作（如：准被测试数据、测试环境）<br> 或者在<strong>测试结束后</strong>做一些后置操作（如：清理测试数据）</p><h3 id="hook-具体写法的栗子-比较长-耐心敲-耐心看" tabindex="-1"><a class="header-anchor" href="#hook-具体写法的栗子-比较长-耐心敲-耐心看" aria-hidden="true">#</a> hook 具体写法的栗子（比较长，耐心敲，耐心看）</h3><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603140328124-324322765.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="运行结果" tabindex="-1"><a class="header-anchor" href="#运行结果" aria-hidden="true">#</a> 运行结果</h4><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603140341751-1760493878.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h4><p>若包含<strong>多级测试套件</strong>，那么父级套件、祖父级套件声明的 hook 函数会作用于所有子级套件的测试用例，孙子级套件的测试用例...以此类推**（如：栗子中的二级套件、孙子级套件）**</p><h3 id="before" tabindex="-1"><a class="header-anchor" href="#before" aria-hidden="true">#</a> before()</h3><ul><li>该测试套件下，所有测试用例的<strong>统一前置</strong>操作</li><li>它在一个 describe() 或 context() 内只会执行一次，在所有 it() 之<strong>前</strong>执行</li><li>在运行结果可以看到是叫 BEFORE ALL</li></ul><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603141040916-1221477156.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="after" tabindex="-1"><a class="header-anchor" href="#after" aria-hidden="true">#</a> after()</h3><ul><li>该测试套件下，所有测试用例的<strong>统一后置</strong>操作</li><li>它在一个  describe()  或 context() 内只会执行一次，在所有 it() 之<strong>后</strong>执行</li><li>在运行结果可以看到是叫  AFTER ALL ，而且是在最后一行</li></ul><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603143332828-2141197321.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="beforeeach" tabindex="-1"><a class="header-anchor" href="#beforeeach" aria-hidden="true">#</a> beforeEach()</h3><ul><li>该测试套件下，每个测试用例的<strong>前置</strong>操作</li><li>一个  describe()  或 context() 内有多少个测试用例 it() ，就会执行几次 beforeEach()</li><li>在运行结果可以看到是叫 BEFORE EACH</li></ul><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603143725036-2104234506.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="aftereach" tabindex="-1"><a class="header-anchor" href="#aftereach" aria-hidden="true">#</a> afterEach()</h3><ul><li>该测试套件下，每个测试用例的<strong>后置</strong>操作</li><li>一个 describe()  或 context() 内有多少个测试用例 it() ，就会执行几次  afterEach()</li><li>在运行结果可以看到是叫 AFTER EACH</li></ul><figure><img src="https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200603144438601-530517176.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',25),g={href:"https://www.cnblogs.com/poloyy/p/13037502.html",target:"_blank",rel:"noopener noreferrer"};function d(f,p){const a=i("ExternalLinkIcon");return r(),t("div",null,[s,e("blockquote",null,[e("p",null,[e("a",g,[n("https://www.cnblogs.com/poloyy/p/13037502.html"),l(a)])])])])}const u=o(c,[["render",d],["__file","Cypress系列（008）--Cypress-编写和组织测试用例篇-之-钩子函数Hook.html.vue"]]);export{u as default};
