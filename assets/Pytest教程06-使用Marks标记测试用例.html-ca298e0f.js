import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as e}from"./app-3f278ba4.js";const t={},o=e(`<h1 id="pytest权威教程06-使用marks标记测试用例" tabindex="-1"><a class="header-anchor" href="#pytest权威教程06-使用marks标记测试用例" aria-hidden="true">#</a> Pytest权威教程06-使用Marks标记测试用例</h1><p>通过使用<code>pytest.mark</code>你可以轻松地在测试用例上设置元数据。例如, 一些常用的内置标记：</p><ul><li>skip - 始终跳过该测试用例</li><li>skipif - 遇到特定情况跳过该测试用例</li><li>xfail - 遇到特定情况,产生一个“期望失败”输出</li><li>parametrize - 在同一个测试用例上运行多次调用(译者注: 参数化数据驱动)</li></ul><p>创建自定义标记或将标记应用于整个测试类或模块很容易。 文档中包含有关标记的示例,详情可参阅[使用自定义标记。</p><blockquote><p>注意：<br> 标记只对测试用例有效,对fixtures方法无效。</p></blockquote><h3 id="在未知标记上引发异常-strict" tabindex="-1"><a class="header-anchor" href="#在未知标记上引发异常-strict" aria-hidden="true">#</a> 在未知标记上引发异常： -strict</h3><p>当使用<code>--strict</code>命令行参数时,未在<code>pytest.ini</code>文件中注册的任何标记都将引发异常。<br> 标记可以通过以下方式注册：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>pytest<span class="token punctuation">]</span>
markers <span class="token operator">=</span>
    slow
    serial
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这可用于防止用户意外输错标记名称。 想要强制执行此操作的测试套件应将<code>--strict</code>添加到<code>addopts</code>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>pytest<span class="token punctuation">]</span>
addopts <span class="token operator">=</span> <span class="token parameter variable">--strict</span>
markers <span class="token operator">=</span>
    slow
    serial
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="标记改造和迭代" tabindex="-1"><a class="header-anchor" href="#标记改造和迭代" aria-hidden="true">#</a> 标记改造和迭代</h3><p><em>3.6版本新函数</em><br> pytest的标记传统地实现是通过简单地在测试函数的<code>__dict__</code>中添加属性来进行标记。结果,标记意外的随着类的集成而传递。此外,使用<code>@pytest.mark</code>装饰器应用的标记和通过<code>node.add_marker</code>添加的标记存储的位置不同,用于检索它们的API也<br> 不一致。<br> 这样,如果不深入了解测试代码内部结构,技术上几乎无法正确使用参数化数据,从而导致在高级的使用方法中出现细微且难以理解的bug。<br> 根据标记声明/更改的方式,你都可以获得一个<code>MarkerInfo</code>对象,其中也可能会包含来自同级类的标记。当使用参数化标记,或<code>node.add_marker</code>时,会丢弃之前的使用装饰器声明的<code>MarkDecorators</code>标记。<code>MarkerInfo</code>对象实际上是使用同一标记名的多个标记的合并视图,当然,<code>MarkerInfo</code>也可以像单个标记一样使用。<br> 最重要的是,即使标记是在类/模块上声明的,实际上,标记只能在函数中访问。原因是模块,类和函数/方法无法以相同的方式访问标记。<br> 在pytest 3.6版本中引入了一个访问标记的新API,以解决初始设计中的问题,提供**_pytest.nodes.Node.iter_markers()**方法以一致的方式迭代标记并重新进行内部处理,这很好地解决了初始设计的问题。</p><h4 id="升级代码" tabindex="-1"><a class="header-anchor" href="#升级代码" aria-hidden="true">#</a> 升级代码</h4><p>不推荐使用原有的<code>Node.get_marker(name)</code>函数,因为它返回一个内部<code>MarkerInfo</code>对象,该对象包含应用于该节点的所有标记的合并名称和所有参数。<br> 通常,有两种方案可以处理标记：<br> 标记互相覆盖。 顺序很重要,但你只需要将你的标记视为单独的标记即可。 例如。 对于测试用例中的<code>log_level(&#39;debug&#39;)</code>会覆盖模块级别的<code>log_level(&#39;info&#39;)</code>。<br> 在这种情况下,可以使用<code>Node.get_closest_marker(name)</code>：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 替换这个:</span>
marker <span class="token operator">=</span> item<span class="token punctuation">.</span>get_marker<span class="token punctuation">(</span><span class="token string">&quot;log_level&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> marker<span class="token punctuation">:</span>
    level <span class="token operator">=</span> marker<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token comment"># 通过这个:</span>
marker <span class="token operator">=</span> item<span class="token punctuation">.</span>get_closest_marker<span class="token punctuation">(</span><span class="token string">&quot;log_level&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> marker<span class="token punctuation">:</span>
    level <span class="token operator">=</span> marker<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在特定条件下使用标记。 例如,<code>skipif(condition)</code>标记,意味着你只想测试所有非condition条件的用例,顺序不重要。你可以将这个标记视为一个满足该条件的集合使用。<br> 在这种情况下,迭代每个标记并单独处理它们的<code>*args</code>和<code>**kwargs</code>参数。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 替换这个：</span>
skipif <span class="token operator">=</span> item<span class="token punctuation">.</span>get_marker<span class="token punctuation">(</span><span class="token string">&quot;skipif&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> skipif<span class="token punctuation">:</span>
    <span class="token keyword">for</span> condition <span class="token keyword">in</span> skipif<span class="token punctuation">.</span>args<span class="token punctuation">:</span>
        <span class="token comment"># eval condition</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment"># 通过这个:</span>
<span class="token keyword">for</span> skipif <span class="token keyword">in</span> item<span class="token punctuation">.</span>iter_markers<span class="token punctuation">(</span><span class="token string">&quot;skipif&quot;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    condition <span class="token operator">=</span> skipif<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token comment"># eval condition</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你不确定或遇到任何难题,你可以考虑提出一个待解决问题。</p><blockquote><p>注意：<br> 在未来的Pytest主要版本中,我们将引入基于类的标记,在这些标记处,标记将不再局限于Mark的实例。</p></blockquote>`,19),i=[o];function c(p,r){return s(),a("div",null,i)}const u=n(t,[["render",c],["__file","Pytest教程06-使用Marks标记测试用例.html.vue"]]);export{u as default};
