import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as n,c as o,a as e,b as l,d as t,f as s}from"./app-d0fb0332.js";const h={},d=s('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><ul><li>在UI自动化测试中，PO是目前最为主流，也是公认最佳的设计模式</li><li>UI自动化测试最初是通过<strong>关键字驱动+数据驱动</strong>的形式来实现，然后升级到PO模式</li></ul><p></p><h2 id="什么是关键字驱动" tabindex="-1"><a class="header-anchor" href="#什么是关键字驱动" aria-hidden="true">#</a> 什么是关键字驱动</h2><ul><li>简单而言，就是将Selenium常用功能进行二次封装</li><li>**譬如：**把查找元素、点击、输入等原生方法进行封装</li><li>**特点：**可以让不懂代码的测试人员也能做自动化测试，彻底地实现测试步骤、测试数据和程序的分离</li></ul><p></p><h3 id="关键字驱动-vs-rf" tabindex="-1"><a class="header-anchor" href="#关键字驱动-vs-rf" aria-hidden="true">#</a> 关键字驱动 vs RF</h3><ul><li>可以把关键字驱动对比用RF（Robot Framework）做的自动化测试，在RF GUI界面调用关键字，并传入参数即可完成一系列的元素操作；</li><li>而我们在Pycharm上完成关键字驱动也是相同道理，封装好Selenium常用方法，然后去调用关键字，不同页面传入不同的参数即可完成一系列的元素操作</li></ul><p></p><h2 id="什么是数据驱动" tabindex="-1"><a class="header-anchor" href="#什么是数据驱动" aria-hidden="true">#</a> 什么是数据驱动</h2><ul><li>固定的程序，固定的测试步骤，使用不同的数据进行测试**【需要多组数据来测试】**</li><li>将代码和数据进行分离，单纯由数据组成文件，再由文件来驱动关键字，最终实现整个自动化的流程</li></ul><p></p><h2 id="什么是关键字驱动-数据驱动" tabindex="-1"><a class="header-anchor" href="#什么是关键字驱动-数据驱动" aria-hidden="true">#</a> 什么是关键字驱动+数据驱动</h2><ul><li>读取数据，将固定格式的数据进行拼接**【读取数据】**</li><li>拼接后的内容作为关键字所需要的参数，进行传入**【传入数据】**</li><li>调用关键字，将执行结果和预期结果进行对比，从而获取单条测试用例执行是否通过的结果**【执行关键字，断言结果】**</li></ul><p>**关键字驱动+数据驱动是一种设计模式哦！ **</p><h2 id="什么是po模式" tabindex="-1"><a class="header-anchor" href="#什么是po模式" aria-hidden="true">#</a> 什么是PO模式</h2><ul><li>PO模式是page object model的缩写，是一种<strong>设计模式</strong></li><li>把待测页面当成一个<strong>页面对象</strong>，一般包含了元素对象的定位和元素操作方法，将页面对象和真实的网站页面一 一映射起来</li><li>比如一个登录页面，使用PO模式后，操作的步骤如下： <ol><li>会先创建一个class，该class就是<strong>登录页面对象类</strong></li><li>类的属性：用户名输入框，密码输入框，登录按钮的<strong>webElenent</strong></li><li>类的方法：各种元素操作的**方法****</li><li>方法里面会调用对象库层的<strong>二次封装Selenium的方法</strong></li><li>测试层从页面操作层调用操作方法，写成<strong>测试用例</strong>，这种模式可以做到定位元素与测试用例分离</li></ol></li><li>所以这样的设计理念就是PO模式</li></ul><p></p><h2 id="po模式的分层" tabindex="-1"><a class="header-anchor" href="#po模式的分层" aria-hidden="true">#</a> PO模式的分层</h2><h3 id="po模式可以把一个页面一般分为三层" tabindex="-1"><a class="header-anchor" href="#po模式可以把一个页面一般分为三层" aria-hidden="true">#</a> PO模式可以把一个页面一般分为三层</h3><p>对象库层：二次封装Selenium的方法<br> 页面操作层（也称：逻辑层）：封装页面的元素对象和元素操作<br> 测试层（也称：业务层）：多个页面操作完成一个业务测试，一般结合单元测试框架（unittest、pytest）来测试</p><h3 id="当然也有分四层的" tabindex="-1"><a class="header-anchor" href="#当然也有分四层的" aria-hidden="true">#</a> 当然也有分四层的</h3><p>对象库层：二次封装Selenium的方法<br> 页面层：封装页面的元素对象<br> 操作层：封装页面的元素操作<br> 测试层：多个页面操作完成一个业务测试</p><h2 id="po模式和关键字驱动-数据驱动有什么区别-po模式的原理" tabindex="-1"><a class="header-anchor" href="#po模式和关键字驱动-数据驱动有什么区别-po模式的原理" aria-hidden="true">#</a> PO模式和关键字驱动+数据驱动有什么区别？（PO模式的原理）</h2><ul><li>升级到PO模式之后，首先将Selenium常用的功能，<strong>结合实际业务</strong>需要进行二次封装；封装的内容是完全贴合实际业务来实现的**【封装Selenium】**</li><li>将元素对象和元素操作进行整合**【元素对象整合】**</li><li>将对象库和测试代码分离，实现数据与代码分离**【数据与代码分离】**</li></ul><p></p><h2 id="po模式给代码带来的优势" tabindex="-1"><a class="header-anchor" href="#po模式给代码带来的优势" aria-hidden="true">#</a> PO模式给代码带来的优势</h2><ul><li>**代码冗余明显降低：**二次封装Selenium方法和提取公共方法，提高代码复用性</li><li>**代码的阅读性明显提升：**因为三层分级，将不同内容进行不同的封装，整体代码阅读性提升</li><li><strong>代码维护性明显提升：<strong>UI测试中，页面若经常变动，代码的维护量随之增多；因为三层分级，我们只需要修改</strong>页面对象的代码</strong>，如<strong>元素对象</strong>或者<strong>操作对象的方法</strong>，不用修改测试用例的代码，也不影响测试用例的正常执行</li><li><strong>降低代码耦合性</strong></li></ul><p></p>',29),c={href:"https://www.cnblogs.com/poloyy/p/12633726.html",target:"_blank",rel:"noopener noreferrer"};function p(u,g){const i=r("ExternalLinkIcon");return n(),o("div",null,[d,e("blockquote",null,[e("p",null,[l("转载： "),e("a",c,[l("https://www.cnblogs.com/poloyy/p/12633726.html"),t(i)])])])])}const b=a(h,[["render",p],["__file","Selenium系列（20）---PageObject模式的详细介绍.html.vue"]]);export{b as default};
